namespace ProductAPI is
    use interlocked_increment = System.Threading.Interlocked.increment;
    use CONCURRENT_MAP = System.Collections.Concurrent.ConcurrentDictionary`2;

    trait ProductStore is
        create_product(product: PRODUCT) -> int;
        update_product(id: int, product: PRODUCT) -> bool;
        get_product(id: int) -> PRODUCT;
        delete_product(id: int) -> bool;
    si

    // note this provides no mutual exclusion to avoid
    // race conditions
    class IN_MEMORY_PRODUCT_STORE: ProductStore is
        _next_id: int;
        _products: CONCURRENT_MAP[int,PRODUCT];

        init() is
            _next_id = -1;
            _products = CONCURRENT_MAP[int,PRODUCT]();
        si

        create_product(product: PRODUCT) -> int is
            let result = interlocked_increment(_next_id ref);

            _products[result] = product;

            return result;            
        si

        get_product(id: int) -> PRODUCT =>
            let result: PRODUCT in
            if _products.try_get_value(id, result ref) then
                result
            else
                null
            fi;

        update_product(id: int, product: PRODUCT) -> bool =>
            _products.try_update(id, product, _products[id]);

        delete_product(id: int) -> bool =>
            let result: PRODUCT in
            _products.try_remove(id, result ref);
    si
si